#!/usr/bin/python3

import argparse
import configparser
from datetime import timedelta
import os
import sys

from parsers.banks import parsers

def import_incoming_statements(dirs, force):
    incoming_dir = dirs['incoming']
    for (dirpath, dirnames, filenames) in os.walk(incoming_dir):
        if dirpath == incoming_dir:
            continue
        bank = os.path.basename(dirpath)
        if bank not in parsers:
            print('unknown bank:', bank, file=sys.stderr)
            continue
        Parser = parsers[bank]
        if filenames:
            print('importing bank statements from', bank)
        dateranges = []
        filenames.sort()
        for f in filenames:
            src_file = os.path.join(dirpath, f)
            parser = Parser(src_file)
            m = parser.parse_metadata()
            print('{m.start_date} → {m.end_date}: {src_file}'
                  .format(src_file=src_file, m=m))
            mid_date = m.start_date + (m.end_date - m.start_date) / 2
            year = str(mid_date.year)
            month = str(mid_date.month).zfill(2)
            dest_dir = os.path.join(dirs['ledgers'], year, month, bank)
            os.makedirs(dest_dir, exist_ok=True)
            dest_file = os.path.join(dest_dir,
                                     os.path.splitext(f)[0] + '.hledger')
            parse_and_write_bank_statement(parser, src_file, dest_file, force)
            dateranges.append((m.start_date, m.end_date))
        dateranges.sort(key=lambda t: t[0])
        for i in range(len(dateranges)-1, 0, -1):
            if dateranges[i-1][1] + timedelta(days=1) == dateranges[i][0]:
                dateranges[i-1] = (dateranges[i-1][0], dateranges[i][1])
                dateranges.pop(i)
        dateranges = ', '.join('{} → {}'.format(*d) for d in dateranges)
        print(f'imported {bank} bank statements for {dateranges}')

def parse_and_write_bank_statement(parser, src_file, dest_file, force):
    if os.path.exists(dest_file):
        if force:
            print(f'WARNING: existing {dest_file} will be overwritten',
                  file=sys.stderr)
        else:
            print(f'WARNING: skipping import of already imported {src_file}',
                  file=sys.stderr)
            return
    try:
        bank_statement = parser.parse()
    except NotImplementedError as e:
        print(f'Warning: couldn\'t parse {src_file}:', e.args,
              file=sys.stderr)
        return
    with open(dest_file, 'w') as f:
        bank_statement.write_ledger(f)

def write_include_files(ledger_root):
    ledger_name = 'journal.hledger'
    for(dirpath, dirnames, filenames) in os.walk(ledger_root):
        if dirpath == ledger_root:
            for i in reversed(range(len(dirnames))):
                if not dirnames[i].isnumeric():
                    dirnames.pop(i)
        dirnames.sort()
        ledger = os.path.join(dirpath, ledger_name)
        with open(ledger, 'w') as f:
            print("; autogenerated file, do not edit\n", file=f)
            for d in dirnames:
                print('include', os.path.join(d, ledger_name), file=f)
            try:
                # prevent infinite loop
                filenames.remove(ledger_name)
            except ValueError:
                pass
            filenames = sorted(f for f in filenames if f.endswith('.hledger'))
            for filename in filenames:
                print('include', filename, file=f)

def read_config():
    config = configparser.ConfigParser()
    if 'dirs' not in config:
        config['dirs'] = {}
    dirs = config['dirs']
    if 'ledgers' not in dirs:
        dirs['ledgers'] = '~/accounting/bank_statements'
    dirs['ledgers'] = os.path.expanduser(dirs['ledgers'])
    assert os.path.exists(dirs['ledgers'])
    if 'incoming' not in dirs:
        dirs['incoming'] = os.path.join(dirs['ledgers'], 'incoming')
    dirs['incoming'] = os.path.expanduser(dirs['incoming'])
    assert os.path.exists(dirs['incoming'])
    return config

if __name__ == '__main__':
    aparser = argparse.ArgumentParser(
            description='import account statement PDFs into hledger')
    aparser.add_argument('--force', dest='force', default=False,
                         action='store_true',
                         help='overwrite existing ledgers')
    aparser.add_argument('--regenerate-includes', dest='regenerate_includes',
                         default=False, action='store_true',
                         help='only regenerate include files; don\'t import '
                              'new bank statements')

    args = aparser.parse_args()

    config = read_config()

    if not args.regenerate_includes:
        import_incoming_statements(config['dirs'], args.force)
    write_include_files(config['dirs']['ledgers'])
